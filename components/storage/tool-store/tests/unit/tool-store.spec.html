<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tool Store Unit Tests</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50 min-h-screen p-8">
  <div class="max-w-4xl mx-auto">
    <header class="mb-8">
      <h1 class="text-3xl font-bold text-gray-800">Tool Store Unit Tests</h1>
      <p class="text-gray-600 mt-2">Testing Registry-based Tool Management</p>
    </header>

    <div id="test-results" class="space-y-3"></div>
    <div class="mt-8 bg-gray-900 rounded-lg shadow-md p-6">
      <div id="console-output" class="font-mono text-sm text-green-400 space-y-1 max-h-64 overflow-y-auto"></div>
    </div>
  </div>

  <script type="module">
    window.onerror = function(msg, url, line, col, error) {
      console.error('Global Error:', msg, '\nURL:', url, '\nLine:', line, '\nCol:', col, '\nError:', error);
      document.getElementById('console-output').innerHTML += `<div class="text-red-500">Global Error: ${msg}</div>`;
    };

    import { ToolStore } from '../../src/index.js';
    import { IndexedDBProvider } from '../../../../core/indexeddb-provider/src/index.js';

    // Helper to clear DB before tests
    async function clearDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.deleteDatabase('aardvark-db');
        req.onsuccess = () => resolve();
        req.onerror = () => reject(req.error);
        req.onblocked = () => console.warn('Delete blocked');
      });
    }

    // Test Framework
    class TestRunner {
      constructor() {
        this.tests = [];
        this.passCount = 0;
        this.failCount = 0;
      }

      test(name, fn) {
        this.tests.push({ name, fn });
      }

      async runAll() {
        for (const test of this.tests) {
          await this.runTest(test);
        }
        this.showSummary();
      }

      async runTest(test) {
        const container = document.getElementById('test-results');
        const el = document.createElement('div');
        el.className = 'bg-white rounded-lg shadow p-4 border-l-4 border-yellow-400';
        el.innerHTML = `<span class="font-medium">⏳ ${test.name}</span>`;
        container.appendChild(el);

        try {
          await test.fn();
          this.passCount++;
          el.className = 'bg-white rounded-lg shadow p-4 border-l-4 border-green-500';
          el.innerHTML = `<span class="font-medium">✓ ${test.name}</span>`;
        } catch (error) {
          this.failCount++;
          el.className = 'bg-white rounded-lg shadow p-4 border-l-4 border-red-500';
          el.innerHTML = `<span class="font-medium">✗ ${test.name}</span><div class="text-sm text-red-600 mt-2">${error.message}</div>`;
          console.error(error);
        }
      }

      showSummary() {
        const badge = document.createElement('div');
        badge.id = 'status-badge';
        badge.style.display = 'none';
        badge.textContent = this.failCount === 0 ? 'All Tests Passed!' : 'Tests Failed';
        document.body.appendChild(badge);
        
        // For run-tests.js scraper
        const total = document.createElement('div'); total.id = 'total-count'; total.textContent = this.tests.length;
        const pass = document.createElement('div'); pass.id = 'pass-count'; pass.textContent = this.passCount;
        const fail = document.createElement('div'); fail.id = 'fail-count'; fail.textContent = this.failCount;
        document.body.append(total, pass, fail);
      }
    }

    // Assertions
    const assert = {
      equal: (a, b, msg) => { if (a !== b) throw new Error(`${msg}: expected ${b}, got ${a}`); },
      ok: (val, msg) => { if (!val) throw new Error(msg || 'Expected truthy value'); }
    };

    const runner = new TestRunner();

    // Setup
    runner.test('Setup: Clear Database', async () => {
      await clearDB();
      assert.ok(true);
    });

    // Tests
    runner.test('Initialize ToolStore (Empty)', async () => {
      const store = new ToolStore();
      await store.initialize();
      const tools = store.listTools();
      assert.equal(tools.length, 0, 'Registry should be empty');
    });

    runner.test('Register Tool directly', async () => {
      const store = new ToolStore();
      await store.initialize();

      const tool = {
        name: 'test-tool',
        version: '1.0.0',
        func: 'return true;',
        schema: { description: 'Test' },
        type: 'user',
        permissions: []
      };

      await store.registerTool(tool);
      
      const retrieved = store.getTool('test-tool');
      assert.ok(retrieved, 'Should retrieve tool');
      assert.equal(retrieved.name, 'test-tool', 'Name should match');
      assert.ok(retrieved.id, 'Should have auto-generated ID');
    });

    runner.test('Add Pending Tool', async () => {
      const store = new ToolStore();
      await store.initialize();

      const tool = {
        name: 'pending-tool',
        version: '1.0.0',
        func: 'return false;',
        schema: { description: 'Pending' },
        type: 'user',
        permissions: []
      };

      const id = await store.addPendingTool(tool, 'user');
      assert.ok(id, 'Should return pending ID');

      const pendingList = await store.listPendingTools();
      const pending = pendingList.find(p => p.toolId === id);
      
      assert.ok(pending, 'Should find in pending list');
      assert.equal(pending.status, 'pending', 'Status should be pending');
    });

    runner.test('Approve Tool', async () => {
      const store = new ToolStore();
      await store.initialize();

      // Create pending
      const tool = {
        name: 'to-approve',
        version: '1.0.0',
        func: '...',
        schema: { description: '...' },
        type: 'user',
        permissions: []
      };
      const id = await store.addPendingTool(tool, 'user');

      // Approve
      await store.approveTool(id);

      // Verify in registry
      const registered = store.getTool('to-approve');
      assert.ok(registered, 'Tool should be in registry');

      // Verify pending status
      const pendingList = await store.listPendingTools(); // Returns only pending
      const stillPending = pendingList.find(p => p.toolId === id);
      assert.ok(!stillPending, 'Should no longer be in pending list');
    });

    runner.test('Reject Tool', async () => {
      const store = new ToolStore();
      await store.initialize();

      const tool = {
        name: 'to-reject',
        version: '1.0.0',
        func: '...',
        schema: {},
        type: 'user',
        permissions: []
      };
      const id = await store.addPendingTool(tool, 'user');

      await store.rejectTool(id, 'Bad code');

      const pendingList = await store.listPendingTools();
      const stillPending = pendingList.find(p => p.toolId === id);
      assert.ok(!stillPending, 'Should no longer be in pending list');
      
      const registered = store.getTool('to-reject');
      assert.ok(!registered, 'Should not be in registry');
    });

    runner.test('Hydrate from DB on Init', async () => {
      // Create new store instance to simulate reload
      const store = new ToolStore();
      await store.initialize();
      
      const tool = store.getTool('test-tool'); // From previous test
      assert.ok(tool, 'Should load existing tools from DB');
    });

    runner.runAll();
  </script>
</body>
</html>